<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on Yange Zheng</title>
    <link>https://yzheng.me/blogs/</link>
    <description>Recent content in Blogs on Yange Zheng</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 13 Oct 2019 22:43:40 +0200</lastBuildDate>
    
	<atom:link href="https://yzheng.me/blogs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title> look at this</title>
      <link>https://yzheng.me/blogs/what-about-this/</link>
      <pubDate>Sun, 13 Oct 2019 22:43:40 +0200</pubDate>
      
      <guid>https://yzheng.me/blogs/what-about-this/</guid>
      <description> here is second post Class class = new Class; class.print(); Myclass my = new Myclass();  </description>
    </item>
    
    <item>
      <title>this is the title</title>
      <link>https://yzheng.me/blogs/my-first-post/</link>
      <pubDate>Sun, 13 Oct 2019 22:41:21 +0200</pubDate>
      
      <guid>https://yzheng.me/blogs/my-first-post/</guid>
      <description> Am I coool to try this? this is  and this  like this or not like this  more this is for |  what about now     more </description>
    </item>
    
    <item>
      <title>LA 2 总结</title>
      <link>https://yzheng.me/blogs/2019-09-22-la_summary/</link>
      <pubDate>Sun, 22 Sep 2019 22:41:21 +0200</pubDate>
      
      <guid>https://yzheng.me/blogs/2019-09-22-la_summary/</guid>
      <description> Jordan Normalform 计算Jordansche Normalform  CPΦ(X) := det(X*IdV - Φ) Eig(Φ,λ) := Kern(Φ - λ*IdV) 对于某个Eigenwert λ，关于λ 的Jordanblocks 的长度 = dim(Hauptraum zu λ), 也就是λ 的algebraischen Vielfachheit 对于某个Eigenwert λ，关于λ 的Jordankästchen 是dim(Eig(Φ,λ)),也就是geometrische Vielfachheit 对于某个Eigenwert λ，长度大于k 的Kästchen = dim Kk(λ) - dimK(k-1)(λ)  计算Jordanbasis (S: J = S^(-1)AS) 设：我们有两个eigenwert λ和ɲ，其中ɲ 的 algebraischen Vielfacheit = geometrische Vielfachheit. λ的不相等。
 Eig(Φ,ɲ) 的向量直接可以放进S 算出Hauptraum(Φ,λ) 的向量，选随机的的一个 H(λ)/Eig(λ)向量作为b1。 算出 (A-λIdV)*b1 = b2 重复步骤3， H 和Eig 的向量相差次 最后从Eig(λ) 补充不够的向量加入S，保证linear unabhängig 位置排序依照JNF  Skalarprodukte  s heißt symmetrisch, falls s(v,w) = s(w,v) für alle v,w ∈ V s heißt positiv definit, falls s(v,v) &amp;gt;= 0, und s(v,v) = 0 genau dann, wenn v = 0 s heißt Skalarprodukt auf V, falls s symmetrisch und V reell, so heißt das Paar (V,s) euklidischer Vektorraum  </description>
    </item>
    
    <item>
      <title>Access Control</title>
      <link>https://yzheng.me/blogs/2019-07-30-accesscontrol/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yzheng.me/blogs/2019-07-30-accesscontrol/</guid>
      <description>Bell LaPadula A state machine model used for enforcing access control in government and military applications.
Definition  eine Menge S von Subjekten eine Menge O von Objekten eine Menge A = {read, write, append, excute} von Zugriﬀsoperation eine halbgeordnete Menge L von Sicherheitsleveln, auf der ein eindeutiges Maximum deﬁniert ist B ⊆ S × O × A die Menge aller aktuellen Zugriﬀe ist M = m(i,j)(i=..,j=&amp;hellip;),die Zugriﬀskontrollmatrix ist, deren Eintrag m(i,j) ⊆ A die erlaubten Zugriﬀe des Subjektes i auf das Objekt j beschreibt F = (f s , f c , f o ) ein Funktionstripel:  f s : S → L weist jedem Subjekt ein maximales Sicherheitslevel zu f c : S → L weist jedem Subjekt sein aktuelles Sicherheitslevel zu f o : O → L weist jedem Objekt ein Sicherheitslevel zu   Discretionary-Security/ds-Eigenschaft  user&amp;rsquo;s action is what it has predefined  ∀(s, o, a) ∈ B : a ∈ m(s,o)</description>
    </item>
    
    <item>
      <title>Asymmetrische Authentifikation</title>
      <link>https://yzheng.me/blogs/2019-07-20-asymmetirscheauthentifikation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yzheng.me/blogs/2019-07-20-asymmetirscheauthentifikation/</guid>
      <description>Digitale Sinaturschemata  (pk,sk) &amp;lt;- Gen(1^k) wie bei Public-Key-Verschlüsselung. Signieren: σ &amp;lt;- Sig(sk,M) Verifizieren: Ver(pk,M,σ) = {0,1}  EUF-CMA (Existential Unforgeability under Chosen Message Attack): Schema IND-CPA-sicher ⇔ kein PPT-Angreifer A wins. 1. A has pk and access to Sig(sk,)-Orakel 2. A gives (M,σ) 3. A wins, when Ver(pk,M,σ) = 1 and M != M. RSA als Signaturschema sig(sk,M) = M^d mod N
Ver(pk,M,σ)=1 :&amp;lt;=&amp;gt; M=σ^e mod N
Problem bei RSA:  Unsinnige Nachrichten können signiert werden.</description>
    </item>
    
    <item>
      <title>Asymmetrische Encryption</title>
      <link>https://yzheng.me/blogs/2019-07-16-asymmetrischeencryption/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yzheng.me/blogs/2019-07-16-asymmetrischeencryption/</guid>
      <description>RSA Process RSA Key generation  choose P != Q, both prime N = P x Q, λ(N) = (P-1)(Q-1) pick e from (3,&amp;hellip;,λ(N)-1), ggt(e,λ(N)) = 1 calculate d ≡ e^(−1) (mod λ(N)). //d⋅e ≡ 1 (mod λ(n)) pk = (N,e); sk = (N,d)  Encryption c(m) ≡ m^(e) mod N
Decryption m&amp;copy; ≡ c^(d) mod N
Tricks zum Rechnen:  51^2 mod 59 = (59-8)^2 mod 59 = (-8)^2 mod 59 3^60 mod 59 = 3^(60 mod 58) mod 59 = 3^2 mod 59.</description>
    </item>
    
    <item>
      <title>Block Cipher</title>
      <link>https://yzheng.me/blogs/2019-07-24-blockcipher/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yzheng.me/blogs/2019-07-24-blockcipher/</guid>
      <description>Electronic Codebook Mode (ECB-Modus)  Teile M in l Bit Blöcke M1, M2 &amp;hellip; Mn ∈ {0, 1}^l auf Setze C := (C1 , &amp;hellip; ) mit Ci := E(K, Mi) ∈ {0, 1}^l Entschlüsselung funktioniert genauso, nur mit D  Cipher Block Chaining Mode (CBC) + M: Message; C: Ciphertext; IP: Initial Vector; E: Encryption Algorithm; K: key
1. Encryption: + M = M1 + M2 + &amp;hellip; + Mn + C0 = IV + C1 = E(K, M1 Xor C0) + C2 = E(K, M2 Xor C1) + C = C1 + C2 + &amp;hellip; + Cn</description>
    </item>
    
    <item>
      <title>Encryption Methods for Kids</title>
      <link>https://yzheng.me/blogs/2019-07-29-kidscipher/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yzheng.me/blogs/2019-07-29-kidscipher/</guid>
      <description>Cäser Cipher Enc(K, M) = (Mi + K mod 26)
Bijective Projection * Plain: ABCDEFGHIJKLMNOPQRSTUVWXYZ * Cipher: XYZABCDEFGHIJKLMNOPQRSTUVW
Example: + Plaintext: THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG + Ciphertext: QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD
Problem: + no Schlüsselraum, (K ∈ {0, &amp;hellip; , 25}) + means: if M make sense, just try around then you find K
Hacking tips: + Get the most frequent letter out, guessing it&amp;rsquo;s &amp;lsquo;E&amp;rsquo; (if English).</description>
    </item>
    
    <item>
      <title>Frontend-verwendete Technologien</title>
      <link>https://yzheng.me/blogs/2019-03-24-frontend_verwendete_technologien/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yzheng.me/blogs/2019-03-24-frontend_verwendete_technologien/</guid>
      <description>In our frontend developing, we have received very much help from the following three Technologies.
Angular Angular ist ein von Google entwickeltes JavaScript-Framework für interaktives Webdesign. Es eignet sich besonders für die Entwicklung Single-Page-Applications (SPA).
(1.1) Angular basiert auf Komponenten, die zusammen Daten austauschen
(1.2) Angular ist mit TypeScript geschrieben. (eine JavaScript Erweiterung ab der Versi-on ES6)
(1.3) Design, Template, Test und Datenverarbeitung sind für jede Komponente in verschiedenen Dateien getrennt.</description>
    </item>
    
    <item>
      <title>Grundbegriffe der Informatik</title>
      <link>https://yzheng.me/blogs/2019-08-05-grundbegriffederinformatik/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yzheng.me/blogs/2019-08-05-grundbegriffederinformatik/</guid>
      <description>Wörter  Ein endliches Alphabet Σ ist eine endliche Menge von Symbolen. Eine endliche Folge von Symbolen aus Σ heißt Wort (über Σ). In der Regel ist die Variable für ein Wort w. Die Menge aller Wörter über Σ heißt Σ∗ . Das heißt w ∈ Σ∗. Die Länge von w ist │w│. Das leere Wort ε mit │ε│ = 0 ist ∈ Σ∗ (∀Σ) Der Operator · bezeichne die Konkatenation, also Hintereinanderreihung, von Wörtern w1 &amp;hellip; wn.</description>
    </item>
    
    <item>
      <title>HM Sätze Interpretation</title>
      <link>https://yzheng.me/blogs/2019-08-29-hm_satz/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yzheng.me/blogs/2019-08-29-hm_satz/</guid>
      <description>Eindimensionale Analysis 1. Zahlen Axiome der reellen Zahlen  Sei M ⊂ R, M ≠ ∅: M heißt nach oben beschränkt: ⇔ ∃γ∈R, ∀x∈M, x≤γ. In diesem Fall heißt γ obere Schranke(untere Schranke analog) von M. Ist γ eine obere Schranke von M und gilt für jede weitere obere Schranke ñ von M : γ ≤ ñ, (d.h. γ ist kleinste obere Schranke von M), so heißt γ das Supremum(Inﬁmum analog) von M.</description>
    </item>
    
    <item>
      <title>Informationstheorie</title>
      <link>https://yzheng.me/blogs/2019-08-06-informationstheorie/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yzheng.me/blogs/2019-08-06-informationstheorie/</guid>
      <description>Deﬁnition von Information(信息量) Information I: des Auftretens eines Zeichens k + Information soll nie negativ sein: I ≥ 0 + Ein sicheres Ereignis soll keine Information liefern: Pr[(Pi = 1)] ⇒ I = 0 + Information soll stetig sein + Die Information einer Zeichenkette soll gleich der Summe der Einzelinformationen sein: I(pi·pj) = I(pi) + I(pj)
Sei p eine Wahrscheinlichkeit, die Information von p zur Basis b ist deﬁniert als:</description>
    </item>
    
    <item>
      <title>Komplexitätstheorie</title>
      <link>https://yzheng.me/blogs/2019-08-11-komplexit%C3%A4tstheorie/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yzheng.me/blogs/2019-08-11-komplexit%C3%A4tstheorie/</guid>
      <description>Deﬁnition: Problem Ein Problem Π ist gegeben durch: + eine allgemeine Beschreibung aller vorkommenden Parameter + eine genaue Beschreibung der Eigenschaften, die die Lösung haben soll Ein Problembeispiel /(Instanz) von Π erhalten wir, indem wir die Parameter von Π festlegen.
Deﬁnition: Kodierungsschema  Ein Kodierungsschema s ordnet jedem Problembeispiel eines Problems eine Zeichenkette oder Kodierung über einem Alphabet Σ zu. Die Inputlänge eines Problembeispiels ist die Anzahl des Symbole seiner Kodierung.</description>
    </item>
    
    <item>
      <title>LA Sätze Interpretation</title>
      <link>https://yzheng.me/blogs/2019-09-14-la_satz/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yzheng.me/blogs/2019-09-14-la_satz/</guid>
      <description>III.Vektorräume 7 Basis und Dimension von Vektorräumen Eine Teilmenge B eines Vektorraumes V heißt Basis von V , wenn sie erzeugend und linear unabhängig ist.
解读： 所谓一个线性空间的basis，就是一组vektor。这组vektor 满足erzeugend 和linear unabhängigkeit 的关系。
7.3 Basisdarstellung und Basiswechsel Sei V ein n-dimensionaler -Vektorraum und B = {b1,..,bn} eine Basis von V. Nach der Deﬁnition einer Basis als linear unabhängiges Erzeugendensystem hat jeder Vektor v ∈ V eine Basisdarstellung
 v = sum(vi*bi,i=1→n)  言辞： Basisdarstellung 就是用basis 来表示一个vektor。vi 是 bi 的Koeffizienten, 即需要多少个bi。</description>
    </item>
    
    <item>
      <title>Merkle–Damgård construction</title>
      <link>https://yzheng.me/blogs/2019-07-25-merkledamgardconstruction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yzheng.me/blogs/2019-07-25-merkledamgardconstruction/</guid>
      <description> Merkle–Damgård construction is a method to build collision-resistant cryptographic hash functions from collision-resistant one-way compression functions.
Process  M* = M1 + M2 + M3 + &amp;hellip; + Mn Hi := f(Hi-1 + Mi); 1&amp;lt;i&amp;lt;n   MD-compliant padding  M is a prefix of Pad(M) length(M) = length(M&amp;rsquo;) =&amp;gt; len(Pad(M))=len(Pad(M&amp;rsquo;)) len(M) != len(M&amp;rsquo;) =&amp;gt; the last block of Pad(M) != last block of Pad(M&amp;rsquo;)  </description>
    </item>
    
    <item>
      <title>NP-completeness</title>
      <link>https://yzheng.me/blogs/2019-08-05-npcompleteness/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yzheng.me/blogs/2019-08-05-npcompleteness/</guid>
      <description>Deﬁnition Eine polynomiale Transformation einer Sprache L1 ⊆ Σ1∗ in eine Sprache L2 ⊆ Σ2∗ ist eine Funktion f : Σ1∗ → Σ2∗ mit den folgenden Eigenschaften: 1. Es existiert eine polynomiale deterministische Turing-Maschine, die f berechnet. 2. Für alle x ∈ Σ1^∗ gilt: x ∈ L1 ⇔ f(x) ∈ L2.
Wir schreiben dann L1 ∝ L2 (L1 ist polynomial transformierbar in L2 ). Intuitiv bedeutet L1 ∝ L2 , dass L2 gleich schwierig oder schwieriger als L 1 ist.</description>
    </item>
    
    <item>
      <title>Precomputed hash chains and Rainbow table</title>
      <link>https://yzheng.me/blogs/2019-07-02-precomputedhashchainsandrainbowtable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yzheng.me/blogs/2019-07-02-precomputedhashchainsandrainbowtable/</guid>
      <description>Reversing Cryptographic Hash Functions  What to do if you have a hashed Message H(msg), and you want to have &amp;lsquo;msg&amp;rsquo;?
 Because the hash function is always one way, the way to get the message from the hashed code is to try a lot with different word, and see if you end up have same hashed code as H(msg).
Precomputed Hash Chains We trade time with space. What do we do is, we compute the H(*) before everything happened.</description>
    </item>
    
    <item>
      <title>Security Games</title>
      <link>https://yzheng.me/blogs/2019-07-26-securitygames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yzheng.me/blogs/2019-07-26-securitygames/</guid>
      <description>IND-CPA (Indistinguishability under Chosen Plaintext Attack) 言辞：攻击者生成两条等长的消息{a,b}，挑战者随机决定加密其中的一条消息，攻击者试图猜测被加密的是哪条消息。
Schema IND-CPA-sicher ⇔ kein eﬃzienter Angreifer A kann Chiﬀrate von selbstgewählten Klartexten unterscheiden 1. A erhält im Folgenden Zugriﬀ auf Enc(K, ·)-Orakel 2. A wählt zwei Nachrichten M (1) , M (2) gleicher Länge 3. A erhält C∗ := Enc(K, M (b) ) für gleichverteiltes b ∈ {1, 2} 4. A gewinnt, wenn er b richtig rät EUF-CMA (Existential Unforgeability under Chosen Message Attack): 言辞：攻击者有pk 和 Sig(sk,M) Oracle 的权限，攻击者生成伪造的信息和签名；攻击者获胜，如果伪造的签名解锁后等于被伪造的信息。</description>
    </item>
    
    <item>
      <title>Turing-Maschinen</title>
      <link>https://yzheng.me/blogs/2019-08-11-turing-maschinen/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yzheng.me/blogs/2019-08-11-turing-maschinen/</guid>
      <description>Die Registermaschine (RAM) Die RAM besteht aus: + Ein Programm besteht aus einer Folge von Befehlen. + Programmzeilen sind durchnummeriert. + Der Befehlszähler b startet bei 1 und enthält jeweils die Nummer des nächsten auszuführenden Befehls.  In den ersten Registern steht zu Beginn der Berechnung die Eingabe. In den übrigen Registern steht 0. Am Ende der Berechnung stehen die Ausgabedaten in vorher festgelegten Registern. Den Inhalt des Registers i bezeichnen wir mit c(i).</description>
    </item>
    
    <item>
      <title>your title</title>
      <link>https://yzheng.me/blogs/template/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yzheng.me/blogs/template/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>